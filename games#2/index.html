<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Coletar Moedas – Jogo em HTML + JS</title>

  <style>
    /* ====== ESTILO BÁSICO DA PÁGINA ====== */
    :root {
      --bg: #0f172a;   /* azul bem escuro */
      --panel: #111827;/* cinza chumbo */
      --text: #e5e7eb; /* cinza claro */
      --accent: #22c55e; /* verde para acentos */
      --warn: #ef4444;   /* vermelho para dano */
      --coin: #fbbf24;   /* dourado das moedas */
    }

    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Helvetica Neue", Arial;
      color: var(--text);
      background: radial-gradient(1000px 600px at 50% -20%, #1f2937, var(--bg));
      display: grid;
      place-items: center;
      min-height: 100svh; /* ocupa altura da tela em mobile também */
    }

    .wrap {
      width: min(900px, 95vw);
    }

    .hud {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: center;
      margin-bottom: 10px;
    }

    .stats {
      display: flex;
      gap: 14px;
      flex-wrap: wrap;
      font-weight: 600;
    }

    .stats span { opacity: .9; }
    .stats .good { color: var(--accent); }
    .stats .bad  { color: var(--warn); }

    .controls {
      display: flex;
      gap: 8px;
    }

    button {
      appearance: none;
      border: 0;
      background: var(--panel);
      color: var(--text);
      padding: 8px 14px;
      border-radius: 12px;
      cursor: pointer;
      font-weight: 600;
      transition: transform .05s ease, opacity .2s ease, background .2s ease;
      outline: 2px solid transparent;
    }

    button:hover { background: #0b1220; }
    button:active { transform: translateY(1px) scale(.99); }

    canvas {
      width: 100%;                /* responsivo visualmente */
      aspect-ratio: 16/9;         /* mantém proporção */
      background: #020617;        /* quase preto */
      outline: 2px solid #1f2937; /* borda discreta */
      border-radius: 16px;
      image-rendering: pixelated; /* vibe retrô */
    }

    .help {
      margin-top: 10px;
      font-size: .95rem;
      opacity: .85;
    }
    .kbd {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      padding: 2px 6px;
      border-radius: 6px;
      background: #0b1220;
      border: 1px solid #172033;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="hud">
      <div class="stats">
        <span>Moedas: <b id="score">0</b></span>
        <span>Vidas: <b id="lives" class="bad">3</b></span>
        <span>Tempo: <b id="time">60</b>s</span>
        <span>Nível: <b id="level" class="good">1</b></span>
      </div>
      <div class="controls">
        <button id="btnStart">Iniciar</button>
        <button id="btnPause">Pausar</button>
        <button id="btnReset">Reiniciar</button>
      </div>
    </div>

    <!-- Canvas real com resolução fixa; CSS escala sem perder proporção -->
    <canvas id="game" width="800" height="450"></canvas>

    <p class="help">
      Controle o quadrado <span class="kbd">⬜</span> com <span class="kbd">W</span>/<span class="kbd">A</span>/<span class="kbd">S</span>/<span class="kbd">D</span> ou setas.
      Pegue as <span class="kbd">● moedas</span> e desvie dos <span class="kbd">■ inimigos</span>. Jogo acaba quando o tempo zera ou as vidas acabam.
    </p>
  </div>

  <script>
    // ============================
    // SEÇÃO 1: VARIÁVEIS GERAIS
    // ============================

    /** @type {HTMLCanvasElement} */
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    // Referências a elementos da HUD (pontuação, vidas, etc.)
    const elScore = document.getElementById('score');
    const elLives = document.getElementById('lives');
    const elTime  = document.getElementById('time');
    const elLevel = document.getElementById('level');

    // Botões
    const btnStart = document.getElementById('btnStart');
    const btnPause = document.getElementById('btnPause');
    const btnReset = document.getElementById('btnReset');

    // Estado global simples do jogo
    const state = {
      running: false,   // indica se o loop está rodando
      paused: false,    // indica se está pausado
      score: 0,
      lives: 3,
      timeLeft: 60,     // segundos
      level: 1,
      lastFrame: 0,     // timestamp do último frame
      acc: 0            // acumulador para contagem de tempo
    };

    // Controle de teclado: usamos um Set para saber quais teclas estão pressionadas
    const keys = new Set();

    // ============================
    // SEÇÃO 2: CLASSES DO JOGO
    // ============================

    /** Classe base com posição e tamanho. */
    class Entity {
      constructor(x, y, w, h, color = '#fff') {
        this.x = x;       // posição X
        this.y = y;       // posição Y
        this.w = w;       // largura
        this.h = h;       // altura
        this.color = color; // cor de desenho
      }
      draw() {
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.w, this.h);
      }
      // Verifica colisão retângulo-retângulo
      collides(other) {
        return (
          this.x < other.x + other.w &&
          this.x + this.w > other.x &&
          this.y < other.y + other.h &&
          this.y + this.h > other.y
        );
      }
    }

    /** Jogador controlável. */
    class Player extends Entity {
      constructor() {
        super(50, canvas.height/2 - 15, 30, 30, '#60a5fa'); // quadrado azul
        this.speed = 220; // pixels por segundo
      }
      update(dt) {
        // dt = delta time (tempo entre frames) em segundos
        let dx = 0, dy = 0;
        if (keys.has('ArrowLeft') || keys.has('a'))  dx -= 1;
        if (keys.has('ArrowRight')|| keys.has('d'))  dx += 1;
        if (keys.has('ArrowUp')   || keys.has('w'))  dy -= 1;
        if (keys.has('ArrowDown') || keys.has('s'))  dy += 1;

        // Normaliza diagonal para não ser mais rápida que horizontal/vertical
        if (dx !== 0 && dy !== 0) {
          const inv = 1/Math.sqrt(2);
          dx *= inv; dy *= inv;
        }

        this.x += dx * this.speed * dt;
        this.y += dy * this.speed * dt;

        // Mantém dentro do canvas
        this.x = Math.max(0, Math.min(canvas.width  - this.w, this.x));
        this.y = Math.max(0, Math.min(canvas.height - this.h, this.y));
      }
    }

    /** Moeda a ser coletada. */
    class Coin extends Entity {
      constructor() {
        const size = 12;
        super(
          Math.random() * (canvas.width - size),
          Math.random() * (canvas.height - size),
          size,
          size,
          getCoinColor()
        );
        this.ttl = 8 + Math.random() * 4; // tempo de vida em segundos
      }
      update(dt) {
        this.ttl -= dt;
      }
      draw() {
        // Moeda como círculo simples
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x + this.w/2, this.y + this.h/2, this.w/2, 0, Math.PI*2);
        ctx.fill();
      }
    }

    /** Inimigo que persegue lentamente o jogador. */
    class Enemy extends Entity {
      constructor(speedBoost = 0) {
        const size = 22;
        // nasce em bordas aleatórias para variar
        const spawnSide = Math.floor(Math.random() * 4);
        let x = 0, y = 0;
        if (spawnSide === 0) { // esquerda
          x = -size; y = Math.random() * (canvas.height - size);
        } else if (spawnSide === 1) { // direita
          x = canvas.width; y = Math.random() * (canvas.height - size);
        } else if (spawnSide === 2) { // topo
          x = Math.random() * (canvas.width - size); y = -size;
        } else { // base
          x = Math.random() * (canvas.width - size); y = canvas.height;
        }
        super(x, y, size, size, '#ef4444');
        this.speed = 60 + Math.random()*40 + speedBoost; // velocidade em px/s
      }
      update(dt, target) {
        // move-se na direção do jogador (target)
        const cx = this.x + this.w/2;
        const cy = this.y + this.h/2;
        const tx = target.x + target.w/2;
        const ty = target.y + target.h/2;
        const vx = tx - cx;
        const vy = ty - cy;
        const len = Math.hypot(vx, vy) || 1;
        this.x += (vx/len) * this.speed * dt;
        this.y += (vy/len) * this.speed * dt;
      }
    }

    // ============================
    // SEÇÃO 3: SISTEMA DO JOGO
    // ============================

    /** Arrays que guardam objetos ativos. */
    const coins = [];  // moedas na tela
    const enemies = []; // inimigos na tela
    const player = new Player();

    // Spawners (criadores) com contadores de tempo
    const spawn = {
      coinTimer: 0,
      enemyTimer: 0,
      coinEvery: 1.0,   // a cada 1s tenta criar moeda
      enemyEvery: 2.0   // a cada 2s tenta criar inimigo
    };

    /** Sorteia uma cor de moeda com leve variação. */
    function getCoinColor() {
      // Variação em torno do dourado base
      const shades = ['#f59e0b','#fbbf24','#facc15','#fde047'];
      return shades[(Math.random()*shades.length)|0];
    }

    /** Reinicia todos os estados para novo jogo. */
    function resetGame() {
      state.running = false;
      state.paused = false;
      state.score = 0;
      state.lives = 3;
      state.timeLeft = 60;
      state.level = 1;
      state.lastFrame = 0;
      state.acc = 0;
      coins.length = 0; // limpa arrays mantendo referência
      enemies.length = 0;
      player.x = 50;
      player.y = canvas.height/2 - player.h/2;
      spawn.coinTimer = 0;
      spawn.enemyTimer = 0;
      spawn.coinEvery = 1.0;
      spawn.enemyEvery = 2.0;
      updateHUD();
      drawSplash("Pronto para começar! Clique em Iniciar.");
    }

    /** Atualiza os valores exibidos na HUD. */
    function updateHUD() {
      elScore.textContent = state.score.toString();
      elLives.textContent = state.lives.toString();
      elTime.textContent  = Math.ceil(state.timeLeft).toString();
      elLevel.textContent = state.level.toString();
    }

    /** Tela de boas-vindas/pausa simples. */
    function drawSplash(text) {
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = '#0b1220';
      ctx.fillRect(0,0,canvas.width,canvas.height);

      ctx.fillStyle = '#94a3b8';
      ctx.font = '24px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText(text, canvas.width/2, canvas.height/2);
    }

    /** Lida com subir de nível: fica mais difícil. */
    function levelUp() {
      state.level += 1;
      // Acelera spawns e inimigos levemente
      spawn.coinEvery = Math.max(0.6, spawn.coinEvery * 0.95);
      spawn.enemyEvery = Math.max(1.2, spawn.enemyEvery * 0.92);
      enemies.forEach(e => e.speed *= 1.05);
      updateHUD();
    }

    /** Aplica dano ao jogador e verifica fim de jogo. */
    function hitPlayer() {
      state.lives -= 1;
      flash('#1b0b0b'); // feedback visual
      updateHUD();
      if (state.lives <= 0) {
        gameOver('Acabaram as vidas!');
      }
    }

    /** Animação rápida de flash no fundo. */
    function flash(color) {
      ctx.save();
      ctx.fillStyle = color;
      ctx.globalAlpha = 0.35;
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.restore();
    }

    /** Finaliza o jogo e mostra mensagem. */
    function gameOver(reason) {
      state.running = false;
      drawSplash(`${reason} Pontuação final: ${state.score}`);
    }

    // ============================
    // SEÇÃO 4: LOOP PRINCIPAL
    // ============================

    function update(dt) {
      // Atualiza cronômetro do jogo
      state.timeLeft -= dt;
      state.acc += dt;
      if (state.timeLeft <= 0) {
        gameOver('Tempo esgotado!');
        return;
      }

      // A cada 15s sobe de nível
      if (state.acc >= 15) {
        state.acc = 0;
        levelUp();
      }

      // Atualiza jogador
      player.update(dt);

      // Spawns
      spawn.coinTimer += dt;
      spawn.enemyTimer += dt;
      if (spawn.coinTimer >= spawn.coinEvery) {
        spawn.coinTimer = 0;
        if (coins.length < 6) coins.push(new Coin());
      }
      if (spawn.enemyTimer >= spawn.enemyEvery) {
        spawn.enemyTimer = 0;
        if (enemies.length < 6 + state.level) enemies.push(new Enemy(state.level*6));
      }

      // Atualiza moedas e remove as que expiraram
      for (let i = coins.length - 1; i >= 0; i--) {
        const c = coins[i];
        c.update(dt);
        if (c.ttl <= 0) coins.splice(i,1);
        else if (player.collides(c)) {
          state.score += 10;
          coins.splice(i,1);
          flash('rgba(34,197,94,0.25)'); // verde
        }
      }

      // Atualiza inimigos e checa colisões
      for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.update(dt, player);
        if (e.collides(player)) {
          enemies.splice(i,1);
          hitPlayer();
          if (!state.running) return; // já deu game over
        }
      }

      updateHUD();
    }

    function render() {
      // Limpa tela
      ctx.clearRect(0,0,canvas.width,canvas.height);

      // Fundo com leve grade para dar textura
      ctx.save();
      ctx.fillStyle = '#020617';
      ctx.fillRect(0,0,canvas.width,canvas.height);
      ctx.globalAlpha = 0.06;
      ctx.fillStyle = '#94a3b8';
      const step = 25;
      for (let x=0; x<canvas.width; x+=step) ctx.fillRect(x,0,1,canvas.height);
      for (let y=0; y<canvas.height; y+=step) ctx.fillRect(0,y,canvas.width,1);
      ctx.restore();

      // Desenha objetos
      player.draw();
      coins.forEach(c => c.draw());
      enemies.forEach(e => e.draw());
    }

    function loop(ts) {
      if (!state.running || state.paused) return; // interrompe o loop quando parar

      // Calcula delta time (em segundos)
      const now = ts/1000;
      const last = state.lastFrame || now;
      const dt = Math.min(0.033, now - last); // trava dt máx ~30 FPS para estabilidade
      state.lastFrame = now;

      update(dt);
      render();

      // pede o próximo frame
      requestAnimationFrame(loop);
    }

    // ============================
    // SEÇÃO 5: ENTRADAS E BOTÕES
    // ============================

    window.addEventListener('keydown', (e) => {
      const k = e.key.toLowerCase();
      if (['arrowleft','arrowright','arrowup','arrowdown','w','a','s','d'].includes(k)) {
        keys.add(k);
        e.preventDefault(); // evita scroll na página
      }
      if (k === 'p') togglePause();
      if (k === 'r') startGame(true);
    });

    window.addEventListener('keyup', (e) => {
      const k = e.key.toLowerCase();
      keys.delete(k);
    });

    btnStart.addEventListener('click', () => startGame());
    btnPause.addEventListener('click', () => togglePause());
    btnReset.addEventListener('click', () => startGame(true));

    function startGame(forceReset = false) {
      if (forceReset) resetGame();
      if (!state.running) {
        state.running = true;
        state.paused = false;
        state.lastFrame = 0;
        requestAnimationFrame(loop);
      }
    }

    function togglePause() {
      if (!state.running) return;
      state.paused = !state.paused;
      if (state.paused) {
        drawSplash('Pausado – pressione P para continuar');
      } else {
        state.lastFrame = 0; // evita salto de tempo ao despausar
        requestAnimationFrame(loop);
      }
    }

    // Inicializa a primeira tela
    resetGame();
  </script>
</body>
</html>
